# 1. 直接在代码中嵌入文本

将文本直接嵌入到代码中会阻碍软件的本地化进程，因为译者需要阅读代码以确定哪些部分需要翻译，哪些不需要。这种做法也会增加本地化的成本，并且很难（甚至不可能）保证翻译的一致性。

## **正确的做法是使用分离的资源文件**

字符串包括标题、产品名称、错误信息、以及用户在使用应用程序或软件时可能看到的其他任何文本。所有用户可见的字符串都应该当从代码中分离出来，并放到资源文件中。每个字符串需要有一个唯一的名字（也就是我们通常所说的标识符或键），并为该字符串指定不同的翻译值（多语种的情况）。

这些资源文件由某个库加载，该库通过语言和国家或地区（或者"locale"）的组合来确定相应的字符串。

这样的话，就可以把字符串放在外部资源文件中，方便发送给翻译供应商进行各个语种的翻译，从而获得每个locale对应语言的字符串。

为字符串设置key ID时需要考虑周全。每个key ID都应该描述字符串在界面中的作用（比如标题、按钮、标签等）。同时还要确保每个key ID都是唯一的。

有很多文件格式都可以用作资源文件，比较普遍的选择是JSON、XML、gettext、或YAML。

根据不同的编程语言或框架，通常会有一个比较通用的标准格式。

在Python中，GNU gettext系统是一个比较普遍的选择。可以为每个locale创建一个包含可翻译字符串的.po资源文件。

```
# ./locales/en_US/LC_MESSAGES/messages.po
msgid "button_order"
msgstr "Order Now"

msgid "login_message"
msgstr "Welcome back!"
```

```
# ./locales/de_DE/LC_MESSAGES/messages.po
msgid "button_order"
msgstr "Jetzt bestellen"

msgid "login_message"
msgstr "Willkommen zurück!""
```

gettext的功能就是用来获取到合适的翻译：

```
import gettext
de_DE = gettext.translation('messages', localedir='locales', languages=['de_DE'])
de_DE.install()
print(gettext("login_message"))
# Willkommen zurück!
print(gettext("button_order"))
# Jetzt bestellen]
```

# 2. 基于像素的布局或用户界面在翻译后需要再编辑

每一种语言都不一样，有简有繁。

与其他语言（比如英语、德语等西方语言）相比，中文文本通常非常紧，所以翻译的长度和密度都会有很大的不同。

如果没有足够的空间，字符串可能会与其他控件重叠或者被截断，所以翻译后的界面需要编辑。

## **预留50%的设计，为字符串提供伸缩的空间**

交互界面必须能够灵活的调整大小以适应翻译后的字符串长度。

你可以在每个标签后面预留额外的空间以适应翻译后可能会变长的字符串。但是，对于紧凑型语言来说，这可能会使界面上的标签和控件之间的距离过长。所以，有的开发者会通过标签右对齐或将标签其置于控件之上的方式，以便适应不同语种字符串长度的变化。

也可以使用布局管理器（layout manager）。布局管理器能够判断不同locale语言读用户界面的影响，通过在运行时对界面上各个部件的像素定位，来对界面布局进行适当的调整。

另一种解决办法是在locale资源文件中规定好每个标签的长度。

# 3. 指定语言时没有指定国家或地区

有时，一种语言会因使用的国家或地区不同而存在细微的差别，比如英国英语和美国英语（en-UK和en-US）。指定语言的时候没有指定国家或地区代码也会给本地化带来困难。

## **使用完整的locale属性**

本地化时要做到尽可能精确，使用locale时，不能仅仅指定语言。Locale完整的属性包含语言和使用该语言的国家或地区代码，比如fr-FR或en-GB。只有完整的属性才支持某一种共同语言在两个不同国家或地区之间的不同的拼写、日期格式和其他差异。

```
# ./locales/en_US/LC_MESSAGES/messages.po
msgid "login_message"
msgstr "Hi there!"
```

```
# ./locales/en_AU/LC_MESSAGES/messages.po
msgid "login_message"
msgstr "G'Day Mate!"
```

# 4. **拼接字符串**

有的开发者喜欢使用占位符创建拼接字符串，这样的话单词和短语的顺序是硬编码的。一个句子会被分割成几个字符串，拼接后可能会出现语法规则和句子结构的问题，也会在翻译过程中给译员造成困扰。

以下是一个反面的例子，在这个例子中结构是固定的，但是句子被分解成了更小的字符串。

```
msgid "welcome_back_msg_start"
msgstr "Hey "

msgid "welcome_back_msg_end"
msgstr ", welcome back!"
```

```
print(gettext('welcome_back_msg_start') + username + gettext('welcome_back_msg_end'))
# Hey John, welcome back!
```

这样的拼接，就像猜词游戏，有时几乎不可能翻译。这会给翻译人员带来极大的困难，因为译员在翻译时只看到到句子的一部分，必须去猜测这些字串究竟是怎么拼接在一起的。

没人会喜欢这种猜谜游戏。

## **永远不要去假设语法结构，谨慎对待文本的颗粒度**

一种语言的句子结构在另一种语言中往往会完全不同。

因此，一个字符串最好是一个完整的句子。

这样译员才能够控制一个句子的结构，自由改变顺序，插入各种前缀、后缀和其他语法元素。

如果一个字符串中不可避免的要使用某个占位符，一定要解释清楚这个占位符的意思，并允许译员在必要时改变词序。还可以在句子层面上设置一个条件，这样拼接会更安全。

以下是一个比较好的可参考例子。在这个字符串中占位符的位置是可以自由移动的，译员可以完全控制句子的结构。

```
msgid "welcome_back_msg"
msgstr "Hey %(username)s, welcome back!"
```

```
print(gettext('welcome_back_msg', username="John"))
# Hey John, welcome back!
```

# **5. 字符损坏或不支持Unicode**

如果使用错误的字符编码，并且源代码中使用不能处理Unicode的数据类型来处理字符串，那么翻译就无法进行。编程语言通常使用系统的默认编码来存储文件。

或者，当你的服务器系统语言是英语，而你所有的用户都在用中文浏览时，你的字符就会被破坏。

## **使用UTF-8编码，切记！**

另一个软件本地化的最佳做法是，使用UTF-8编码。UTF-8是解决这个问题的最好选择，因为它规范了各浏览器和服务器的编码。理想情况下，堆栈中的每一层都应该使用UTF-8编码，包括HTML、HTTP服务器、数据库以及应用程序。但是，如果本地化只涉及到亚洲语言时，可能需要使用UTF-16。

在HTML文档的<head>中指定字符集。

```
<meta http-equiv="content-type" content="text/html; charset=utf-8">
```

确保HTTP服务器发送正确的HTTP Content-Type头。

```
Content-Type: text/html; charset=utf-8
```

数据库使用UTF-8编码：

```
# MySQL
CREATE DATABASE dbname CHARACTER SET utf8 COLLATE utf8_general_ci;
```

# 6. **硬编码数字、单位、日期和时间**

软件本地化不只是单纯的文字翻译，而是涉及到完整的文化呈现。

硬编码的日期、时间或货币格式会给翻译造成麻烦。比如在不同的语言中，或者不同的国家和地区，日期和时间的格式是完全不同的，究竟是应该用26.04.2015，还是04.26.2014，是应该写14:00还是2 p.m.，是1,000英里还是1609公里呢？

## **使用库来支撑不同的locale**

如前所述，不要对数字、单位、日期和时间进行硬编码，先假设它们不需要本地化。

使用可本地化的字符串，让翻译人员决定使用什么格式。

可以将所有的日期和时间存储为标准的ISO格式，并使用一个库来为给定的地区设置格式，这样可以将时间转换为不同的时区。

对于货币和其他数字格式来说也是一样的道理。所以，一定要使用库，为软件需要支持的每一个locale提供相应的本地化文件。

以下是使用Pythons babel库的一个例子：

```
from babel.dates import format_datetime
from babel.numbers import format_currency
print(format_datetime(locale='ru_RU'))
# 26 июля 2013 г., 15:48:18
print(format_currency(10.50, 'EUR', locale='de_DE'))
# 10,50 €
print(format_currency(10.50, 'USD', locale='en_AU'))
# US$10.50
```

# 7. 不重视竖式书写和从右往左阅读的语言

有些语言，比如阿拉伯语和希伯来语是从右往左阅读。还有一些古老的语言，比如汉字、传统的蒙古语、以及一些其他的东亚语言都有着悠久的竖写历史。

## **要为复杂的文本流做好准备**

并不是同样的规则就可以满足所有的语言，需要为复杂的文本流准备专门的版本，例如可以供竖式书写和从右向左阅读的语言使用的版本。

涉及到竖式书写时，要确保字符串不会被旋转90度，而是一个字符被放在另一个的下面。

你可以在资源字符串中放一个方向字符串，并使用该字符串基于当前地域来加载的不同字符样式。CSS中有一个这样的方向属性。

例如：

```
h1 {
    direction: rtl;
}
```

```
<h1>
  Read me from right-to-left.
</h1>
```

# 8. 由于缺少上下文而引起的语言混淆或含糊

如果字符串包括变量、用于特定的上下文或语言含糊不清时，也会给翻译造成很大的困扰。译员在翻译字符串文件的时候通常是看不到环境，那么，译员如何知道 "联系" 这个词是一个按钮的动词还是一个标签的名词呢？

## 提供本地化注释或者使用代码注释

在需要本地化的文件中添加注释和说明。切记！

除了词汇表和风格指南，可以直接在源文件中向译员提供上下文信息，包括提供上下文、为译员写注释、提供替代的短语，这样的信息越多越好。

如果是基于文本的代码文件（比如XML、HTML、JSON等）中的内容需要本地化，一定要使用代码注释。如果是提供excel文件进行翻译，可以在文件中添加一列提供上下文说明，必要时提供环境截图，以便译员能更好的理解和更准确的翻译。

在软件翻译和本地化过程中，上下文为王，上下文越多越好!

# 9. 图片中包含文字

使用图片图片是节省本地化成本的好方法，图片更直观，还可以减少了翻译工作量，并且在视觉上更具有吸引力。

但是，包含文字的图像会给翻译带来很大的痛苦，并且会阻碍翻译过程。甚至会增加你的本地化成本。

## 将文本与图形分开

如果文本与图形是相关联的，可以试着将文本与图像分开，把文本创建为一个单独的部分。

如果文本是可分离的，本地化版本的管理就会简单得多。

最理想的是，图片不包含文字，这样就不需要翻译图片。否则，翻译图片的时候还需要关注跨文化的差异，因为不是所有的图像和符号在不同的文化中都是相同的含义。

# 10. 没有提前为本地化做好充分的准备

一些小小的错误可能就会使软件无法在其他语言中运行。源语言内容中的错误可能在其他语言版本中被复制，甚至放大，然后开发人员可能会花上几个月的时间来修复本地化的错误。

一定要避免这种情况的发生！

## 未雨绸缪，本地化测试宜尽早尽多

从长远来看，尽早并尽可能充分的进行本地化测试，可以避免很多麻烦。

作为一个开发者，在软件本地化之后，可以对本地化版本的翻译文件和字符编码进行自动化测试。

补丁包也需要测试，不只是测试代码错误，还需要检查字符串的语法、大小写、一致性和其他可能出现的本地化问题。

在软件最初的开发阶段就应当考虑到本地化问题，这样才能使后续的本地化顺利进行。

如果能避免本文里描述的这10个常见错误，并遵循业界的最佳实践，那么恭喜你！你的软件完全可以顺利本地化，并且很快进入国际市场。

> 参考文献
>
> [10 Common Mistakes to Avoid in Software Localization](https://phrase.com/blog/posts/10-common-mistakes-in-software-localization/)

